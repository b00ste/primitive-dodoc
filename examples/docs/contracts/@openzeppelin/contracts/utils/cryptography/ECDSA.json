{
  "methods": {},
  "events": {},
  "errors": {},
  "internalMethods": {
    "tryRecover(bytes32,bytes)": {
      "code": "function tryRecover(bytes32 hash, bytes signature) internal pure returns (address, enum ECDSA.RecoverError)",
      "inputs": {},
      "outputs": {},
      "details": "Returns the address that signed a hashed message (`hash`) with\n `signature` or error string. This address can then be used for verification purposes.\n The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n this function rejects them by requiring the `s` value to be in the lower\n half order, and the `v` value to be either 27 or 28.\n IMPORTANT: `hash` _must_ be the result of a hash operation for the\n verification to be secure: it is possible to craft signatures that\n recover to arbitrary addresses for non-hashed data. A safe way to ensure\n this is by receiving a hash of the original message (which may otherwise\n be too long), and then calling {toEthSignedMessageHash} on it.\n Documentation for signature generation:\n - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n _Available since v4.3._"
    },
    "recover(bytes32,bytes)": {
      "code": "function recover(bytes32 hash, bytes signature) internal pure returns (address)",
      "inputs": {},
      "outputs": {},
      "details": "Returns the address that signed a hashed message (`hash`) with\n `signature`. This address can then be used for verification purposes.\n The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n this function rejects them by requiring the `s` value to be in the lower\n half order, and the `v` value to be either 27 or 28.\n IMPORTANT: `hash` _must_ be the result of a hash operation for the\n verification to be secure: it is possible to craft signatures that\n recover to arbitrary addresses for non-hashed data. A safe way to ensure\n this is by receiving a hash of the original message (which may otherwise\n be too long), and then calling {toEthSignedMessageHash} on it."
    },
    "tryRecover(bytes32,bytes32,bytes32)": {
      "code": "function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, enum ECDSA.RecoverError)",
      "inputs": {},
      "outputs": {},
      "details": "Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n _Available since v4.3._"
    },
    "recover(bytes32,bytes32,bytes32)": {
      "code": "function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address)",
      "inputs": {},
      "outputs": {},
      "details": "Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n _Available since v4.2._"
    },
    "tryRecover(bytes32,uint8,bytes32,bytes32)": {
      "code": "function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, enum ECDSA.RecoverError)",
      "inputs": {},
      "outputs": {},
      "details": "Overload of {ECDSA-tryRecover} that receives the `v`,\n `r` and `s` signature fields separately.\n _Available since v4.3._"
    },
    "recover(bytes32,uint8,bytes32,bytes32)": {
      "code": "function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)",
      "inputs": {},
      "outputs": {},
      "details": "Overload of {ECDSA-recover} that receives the `v`,\n `r` and `s` signature fields separately."
    },
    "toEthSignedMessageHash(bytes32)": {
      "code": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message)",
      "inputs": {},
      "outputs": {},
      "details": "Returns an Ethereum Signed Message, created from a `hash`. This\n produces hash corresponding to the one signed with the\n https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n JSON-RPC method as part of EIP-191.\n See {recover}."
    },
    "toEthSignedMessageHash(bytes)": {
      "code": "function toEthSignedMessageHash(bytes s) internal pure returns (bytes32)",
      "inputs": {},
      "outputs": {},
      "details": "Returns an Ethereum Signed Message, created from `s`. This\n produces hash corresponding to the one signed with the\n https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n JSON-RPC method as part of EIP-191.\n See {recover}."
    },
    "toTypedDataHash(bytes32,bytes32)": {
      "code": "function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data)",
      "inputs": {},
      "outputs": {},
      "details": "Returns an Ethereum Signed Typed Data, created from a\n `domainSeparator` and a `structHash`. This produces hash corresponding\n to the one signed with the\n https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n JSON-RPC method as part of EIP-712.\n See {recover}."
    },
    "toDataWithIntendedValidatorHash(address,bytes)": {
      "code": "function toDataWithIntendedValidatorHash(address validator, bytes data) internal pure returns (bytes32)",
      "inputs": {},
      "outputs": {},
      "details": "Returns an Ethereum Signed Data with intended validator, created from a\n `validator` and `data` according to the version 0 of EIP-191.\n See {recover}."
    }
  },
  "path": "@openzeppelin/contracts/utils/cryptography",
  "details": "Elliptic Curve Digital Signature Algorithm (ECDSA) operations. These functions can be used to verify that a message was signed by the holder of the private keys of a given address.",
  "name": "ECDSA"
}
